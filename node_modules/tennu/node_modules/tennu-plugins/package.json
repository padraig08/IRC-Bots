{
  "name": "tennu-plugins",
  "version": "3.1.0",
  "description": "Tennu plugin subsystem",
  "main": "lib/index.js",
  "scripts": {
    "test": "mocha test -R spec"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/Tennu/tennu-plugins.git"
  },
  "keywords": [
    "tennu",
    "plugins"
  ],
  "author": {
    "name": "Ryan S. Scheel",
    "url": "Havvy"
  },
  "license": "ISC",
  "bugs": {
    "url": "https://github.com/Tennu/tennu-plugins/issues"
  },
  "devDependencies": {
    "mocha": "~1.16.2",
    "better-assert": "~1.0.0",
    "sinon": "~1.7.3",
    "deep-eql": "~0.1.1"
  },
  "readme": "[![Build Status](https://travis-ci.org/Tennu/tennu-plugins.png?branch=master)](https://travis-ci.org/Tennu/tennu-plugins)\n\nThis is the Plugins subsystem of the Tennu IRC Bot Framework for Node.\n\nThis module creates a plugin systems that handles loading, dependencies, and roles.\n\nThe main features of this plugin system are:\n\n* Loading of dependencies\n* Initialization of plugins\n* Plugin roles, where plugins of that role expose a common interface.\n* Plugin hooks, where plugins can hook into each initializing plugin.\n\nMultiple examples use [Tennu](https://github.com/Tennu/tennu), since this\nplugin system plugin was designed for it. You can repurpose this system\nfor your plugins.\n\n## Installation\n\n```\nnpm install tennu-plugins\n```\n\n## Initialization of Plugin System\n\n```javascript\nrequire('tennu-plugins')(systemname: string, context: any)\n```\n\nThe systemname is the name of the plugin system, \nand declares the directory names the plugin loader's `use` method\nwill look for plugins in. See PluginLoader#Use() for more.\n\nThe context is the first argument passed the plugin initialization functions.\n\nFor example, in Tennu, where the `client` is passed to each plugin, \nand plugins are stored in `tennu_plugins`, the initialization is:\n\n```javascript\nvar plugins = require('tennu-plugins')('tennu', client)\n```\n\n## What's a Plugin?\n\nA Plugin is an object with the following properties:\n\n```javascript\n{\n    init: function,\n    name: string\n    role: string?,\n    requires: [string]?,\n    requiresRoles: [string]?\n}\n```\n\nThe init function must return an object. This object is known as the plugin instance.\n\n**Note:** The name must exist for initialization, but when using the use() method, \nthe plugins will have their name property rewritten. As such, you don't have to worry\nabout the name property if you only use `use()`.\n\nThe following is the minimally viable plugin:\n\n```javascript\n{\n    init: function () {\n        return {};\n    },\n    name: 'bare'\n}\n```\n\nThe plugin instance can export values for other plugins to use. To do so, these\nvalues must be located on the exports property.\n\nThe plugin instance can also hook into plugins that require it. To do so, the properties\nto hook onto must be defined on the hooks property.\n\n## Exports Property\n\nThe exports property is given to plugins that depend on your plugin through\nthe init function. For example, let's say we have two plugins, A and B.\nPlugin B depends on Plugin A. Plugin A exports a property `exists: true`.\nPlugin B loads plugin A and then logs A's `exist` property to the console.\n\n```javascript\n\n// Plugin A\n{\n    init: function () {\n        return {\n            exports: {exists: true}\n        };\n    },\n    name: 'A'\n}\n\n// Plugin B\n{\n    init: function (context, imports) {\n        console.log(imports['B'].exists);\n        return {\n            exports: {}\n        };\n    },\n    name: 'B'\n    requires: ['A']\n}\n```\n\n## Hooks Property\n\nSometimes a plugin wants to do something with every plugin that uses it.\nFor example, Tennu has a help plugin that hooks into the `'help'` property.\nSo, let's say there's a time plugin that wants to use this hook.\n\nThe time plugin puts `'help'` in the dependencies list, and adds a `help`\nproperty to the plugin instance with the help message.\n\nThis is what it looks like:\n\n```javascript\n\n// Plugin 'help'\n{\n    init: function (client, imports) {\n        // ... initialization code.\n\n        return {\n            // ... other properties\n            hooks: {\n                help: function (pluginName, helpobj) {\n                    // Does stuff with helpobj\n                }\n            }\n        };\n    },\n    name: 'help'\n}\n\n// Plugin 'time'\n{\n    init: function (client, imports) {\n        // ... initialization code.\n\n        return {\n            // ... other properties\n            help: \"Stuff about time.\"\n        }\n    },\n    name: 'time'\n}\n```\n\nNote: In this example, the plugin name and hook name are the same.\nThis is not a requirement. You can name your hooks whatever you want.\n\n## Global Hooks\n\nThe creator of the plugin system can add hooks that apply to all plugins.\n\nGlobal hooks should be added before loading any plugins.\n\nTo do so, use `addHook(hook: String, fn: string -> any -> void)`.\n\nFor example, Tennu adds a 'handlers' global hook.\n\n```javascript\nvar plugins = require('tennu-plugins')('tennu', client, logger);\nplugins.addHook('handlers', function (plugin, handlers) {\n   client.on(handlers); \n});\n```\n\n## Loading Plugins\n\n```javascript\nvar plugins = require('tennu-plugins')('tennu', client, logger);\nvar builtins = ['server', 'actions', 'help', 'user', 'channel'];\nvar toUse = [].concat(builtins, client.config(plugins));\nplugins.use(toUse);\n```\n\nCreate a list of plugins that you want to use, and then pass them to\nplugins.use(names: [String], path: String).\n\nThe plugin system will then [locate](#Locate%20Plugins) and load the plugins in a way\nthat all dependencies are properly met.\n\nThis plugin can throw various errors. The constructors for these errors can be\nfound on the exports object of this plugin.\n\n* UnmetDependency\n* NoSuchPlugin\n* NoSuchRole (Not yet used)\n* CyclicicDependency (Not yet used)\n* PluginInitializationError\n* RegistryKeyAlreadySet\n* HookAlreadyExists\n\n## Locating Plugins\n\nThe second parameter to `use()` is a path. The plugin system will look for the following\nplaces for your plugin:\n\n* %**path**%/%**systemname**%_plugins/%**pluginname**%.js\n* %**path**%/%**systemname**%_plugins/%**pluginname**%/index.js\n* %**path**%/node_plugins/%**systemname**%-%**pluginname**%/\n\nIf it cannot find the plugin there, it will then go up the parent directory, and repeat,\nuntil it either finds the plugin or is at the root.\n\nIf the plugin cannot be found, a NoSuchPlugin error will be thrown.\n\n## Other Functions\n\n* hasPlugin(name: string): boolean\n* hasRole(name: string): boolean\n* isInitializable(plugin: Plugin): boolean\n* initialize(plugin: Plugin): void\n* getPlugin(name: string): exports\n* getRole(name: string): exports\n* getModule(name: string): exports<sup>1</sup>\n\n<sup>1</sup> Alias for getPlugin. Erronously named, but kept for backwards compat. Use getPlugin instead.",
  "readmeFilename": "readme.md",
  "homepage": "https://github.com/Tennu/tennu-plugins",
  "_id": "tennu-plugins@3.1.0",
  "dist": {
    "shasum": "b64001a04d5b7afe91eadd617482480947b6cc9b"
  },
  "_from": "tennu-plugins@^3.1.0",
  "_resolved": "https://registry.npmjs.org/tennu-plugins/-/tennu-plugins-3.1.0.tgz"
}
